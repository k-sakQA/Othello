# Othello - Playwright E2Eãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–ãƒ„ãƒ¼ãƒ« è©³ç´°è¨­è¨ˆæ›¸ï¼ˆPhase 9ç‰ˆï¼‰

**ã‚·ã‚¹ãƒ†ãƒ å**: Othello  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 2.0  
**ä½œæˆæ—¥**: 2025å¹´10æœˆ23æ—¥  
**å¯¾è±¡ãƒ•ã‚§ãƒ¼ã‚º**: Phase 9ï¼ˆå®Œå…¨è‡ªå‹•åŒ–ç‰ˆï¼‰

---

## 1. ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ

### 1.1 ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 
```
Othello/
â”œâ”€â”€ bin/
â”‚   â””â”€â”€ othello.js                    # CLIã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ orchestrator.js               # ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ç®¡ç†
â”‚   â”œâ”€â”€ agents/
â”‚   â”‚   â”œâ”€â”€ othello-planner.js        # ãƒ†ã‚¹ãƒˆåˆ†æãƒ»è¨ˆç”»ç”Ÿæˆ
â”‚   â”‚   â”œâ”€â”€ othello-generator.js      # ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆç”Ÿæˆ
â”‚   â”‚   â””â”€â”€ othello-healer.js         # å¤±æ•—ãƒ†ã‚¹ãƒˆè‡ªå‹•ä¿®å¾©
â”‚   â”œâ”€â”€ analyzer.js                   # ã‚«ãƒãƒ¬ãƒƒã‚¸åˆ†æ
â”‚   â”œâ”€â”€ collector.js                  # ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ‡ãƒ¼ã‚¿åé›†
â”‚   â”œâ”€â”€ reporter.js                   # ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
â”‚   â”œâ”€â”€ playwright-agent.js           # MCPé€šä¿¡ï¼ˆPhase 8å®Œæˆï¼‰
â”‚   â”œâ”€â”€ llm/
â”‚   â”‚   â”œâ”€â”€ claude-client.js          # Claude API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚   â”œâ”€â”€ openai-client.js          # OpenAI API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚   â””â”€â”€ llm-factory.js            # LLMãƒ—ãƒ­ãƒã‚¤ãƒ€é¸æŠ
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ csv-parser.js             # CSVè§£æãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚       â”œâ”€â”€ json-validator.js         # JSONæ¤œè¨¼ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚       â””â”€â”€ logger.js                 # ãƒ­ã‚°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ default.json                  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
â”‚   â””â”€â”€ test-ViewpointList.csv        # ãƒ†ã‚¹ãƒˆè¦³ç‚¹ãƒªã‚¹ãƒˆï¼ˆ23é …ç›®ï¼‰
â”œâ”€â”€ logs/
â”‚   â”œâ”€â”€ execution-history-*.json      # å®Ÿè¡Œå±¥æ­´
â”‚   â””â”€â”€ snapshots/                    # å¤±æ•—æ™‚ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ
â”œâ”€â”€ reports/
â”‚   â”œâ”€â”€ test-plan-iteration-*.md      # ãƒ†ã‚¹ãƒˆè¨ˆç”»æ›¸
â”‚   â”œâ”€â”€ test-analysis.json            # ãƒ†ã‚¹ãƒˆåˆ†æçµæœ
â”‚   â”œâ”€â”€ coverage-report.json          # ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆ
â”‚   â”œâ”€â”€ final-report.html             # æœ€çµ‚HTMLãƒ¬ãƒãƒ¼ãƒˆ
â”‚   â””â”€â”€ bug-reports/                  # ãƒã‚°ãƒ¬ãƒãƒ¼ãƒˆ
â”œâ”€â”€ __tests__/
â”‚   â”œâ”€â”€ agents/
â”‚   â”‚   â”œâ”€â”€ othello-planner.test.js
â”‚   â”‚   â”œâ”€â”€ othello-generator.test.js
â”‚   â”‚   â””â”€â”€ othello-healer.test.js
â”‚   â”œâ”€â”€ orchestrator.test.js
â”‚   â”œâ”€â”€ analyzer.test.js
â”‚   â””â”€â”€ integration/
â”‚       â””â”€â”€ full-cycle.test.js        # E2Eçµ±åˆãƒ†ã‚¹ãƒˆ
â””â”€â”€ docs/
    â”œâ”€â”€ api-reference.md              # APIä»•æ§˜æ›¸
    â””â”€â”€ examples/
        â”œâ”€â”€ hotel-site-test-plan.md   # ã‚µãƒ³ãƒ—ãƒ«ãƒ†ã‚¹ãƒˆè¨ˆç”»
        â””â”€â”€ custom-ViewpointList.csv  # ã‚«ã‚¹ã‚¿ãƒ è¦³ç‚¹ä¾‹
```

---

## 2. ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè©³ç´°è¨­è¨ˆ

### 2.1 bin/othello.jsï¼ˆCLIã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆï¼‰

#### 2.1.1 è²¬å‹™
- ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®è§£æ
- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
- Orchestratorã®èµ·å‹•

#### 2.1.2 ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
```javascript
#!/usr/bin/env node

const Orchestrator = require('../src/orchestrator');
const { parseArgs } = require('../src/utils/cli-parser');
const { loadConfig } = require('../src/utils/config-loader');

async function main() {
  // ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°è§£æ
  const args = parseArgs(process.argv);
  
  // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
  const config = await loadConfig(args.config || './config/default.json');
  
  // å¼•æ•°ã§è¨­å®šã‚’ä¸Šæ›¸ã
  const mergedConfig = {
    ...config,
    url: args.url,
    maxIterations: args.maxIterations || config.maxIterations,
    coverageTarget: args.coverageTarget || config.coverageTarget,
    browser: args.browser || config.browser,
    outputDir: args.output || config.outputDir,
    testAspectsCSV: args.testAspectsCSV || config.testAspectsCSV,
    autoHeal: args.autoHeal !== undefined ? args.autoHeal : config.autoHeal,
    llmProvider: args.llmProvider || config.llmProvider
  };
  
  // Orchestratorèµ·å‹•
  const orchestrator = new Orchestrator(mergedConfig);
  await orchestrator.run();
}

main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
```

#### 2.1.3 å¼•æ•°è§£æï¼ˆparseArgsï¼‰
```javascript
function parseArgs(argv) {
  const args = {};
  for (let i = 2; i < argv.length; i++) {
    if (argv[i] === '--url') {
      args.url = argv[++i];
    } else if (argv[i] === '--max-iterations') {
      args.maxIterations = parseInt(argv[++i], 10);
    } else if (argv[i] === '--coverage-target') {
      args.coverageTarget = parseInt(argv[++i], 10);
    } else if (argv[i] === '--browser') {
      args.browser = argv[++i];
    } else if (argv[i] === '--output') {
      args.output = argv[++i];
    } else if (argv[i] === '--config') {
      args.config = argv[++i];
    } else if (argv[i] === '--test-aspects-csv') {
      args.testAspectsCSV = argv[++i];
    } else if (argv[i] === '--auto-heal') {
      args.autoHeal = true;
    } else if (argv[i] === '--no-auto-heal') {
      args.autoHeal = false;
    } else if (argv[i] === '--llm-provider') {
      args.llmProvider = argv[++i];
    }
  }
  return args;
}
```

---

### 2.2 src/orchestrator.jsï¼ˆã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ç®¡ç†ï¼‰

#### 2.2.1 ã‚¯ãƒ©ã‚¹å®šç¾©
```javascript
const OthelloPlanner = require('./agents/othello-planner');
const OthelloGenerator = require('./agents/othello-generator');
const OthelloHealer = require('./agents/othello-healer');
const PlaywrightAgent = require('./playwright-agent');
const Analyzer = require('./analyzer');
const Reporter = require('./reporter');
const { LLMFactory } = require('./llm/llm-factory');

class Orchestrator {
  constructor(config) {
    this.config = config;
    this.iteration = 0;
    this.coverageHistory = [];
    this.testResults = [];
    
    // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆåˆæœŸåŒ–
    this.llm = LLMFactory.create(config.llmProvider, config.llmConfig);
    this.planner = new OthelloPlanner({ llm: this.llm, config });
    this.generator = new OthelloGenerator({ llm: this.llm, config });
    this.healer = new OthelloHealer({ llm: this.llm, config });
    this.agent = new PlaywrightAgent(config.mcpConfig);
    this.analyzer = new Analyzer(config);
    this.reporter = new Reporter(config);
  }

  async run() {
    console.log('ğŸ­ Othello starting...');
    console.log(`Target URL: ${this.config.url}`);
    console.log(`Coverage target: ${this.config.coverageTarget}%`);
    
    try {
      // MCPã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹
      await this.agent.connect();
      
      // ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
      while (this.shouldContinue()) {
        this.iteration++;
        console.log(`\nğŸ“Š Iteration ${this.iteration}/${this.config.maxIterations}`);
        
        await this.runIteration();
        
        // ã‚«ãƒãƒ¬ãƒƒã‚¸åˆ¤å®š
        const coverage = this.getCurrentCoverage();
        console.log(`Current coverage: ${coverage.aspectCoverage.percentage}%`);
        
        if (coverage.aspectCoverage.percentage >= this.config.coverageTarget) {
          console.log('âœ… Coverage target reached!');
          break;
        }
        
        // åœæ»åˆ¤å®š
        if (this.isStagnant()) {
          console.log('âš ï¸  Coverage stagnant, stopping...');
          break;
        }
      }
      
      // æœ€çµ‚ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
      await this.generateFinalReport();
      
      console.log('ğŸ‰ Othello completed successfully!');
    } catch (error) {
      console.error('âŒ Othello failed:', error);
      throw error;
    } finally {
      await this.agent.disconnect();
    }
  }

  async runIteration() {
    // Step 1: Othello-Planner - ãƒ†ã‚¹ãƒˆåˆ†æãƒ»è¨ˆç”»ç”Ÿæˆ
    console.log('  1ï¸âƒ£  Planner: Analyzing and generating test plan...');
    const testPlan = await this.planner.generateTestPlan({
      url: this.config.url,
      testAspectsCSV: this.config.testAspectsCSV,
      existingCoverage: this.getCurrentCoverage(),
      iteration: this.iteration
    });
    
    // Step 2: Othello-Generator - ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆç”Ÿæˆ
    console.log('  2ï¸âƒ£  Generator: Generating test scripts...');
    const snapshot = await this.agent.getSnapshot();
    const testScripts = await this.generator.generate({
      testCases: testPlan.testCases,
      snapshot,
      existingCoverage: this.getCurrentCoverage()
    });
    
    // Step 3: Playwright MCP - ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    console.log('  3ï¸âƒ£  Agent: Executing tests...');
    const executionResults = await this.executeTests(testScripts);
    
    // Step 4: LLM AI - çµæœåˆ†æ
    console.log('  4ï¸âƒ£  LLM: Analyzing results...');
    const analysis = await this.analyzeResults(executionResults, testPlan);
    
    // Step 5: Othello-Healer - å¤±æ•—ãƒ†ã‚¹ãƒˆä¿®å¾©
    if (this.config.autoHeal) {
      console.log('  5ï¸âƒ£  Healer: Healing failed tests...');
      await this.healFailedTests(executionResults, analysis);
    }
    
    // Step 6: Analyzer - ã‚«ãƒãƒ¬ãƒƒã‚¸ç®—å‡º
    console.log('  6ï¸âƒ£  Analyzer: Calculating coverage...');
    const coverage = await this.analyzer.analyze({
      testPlan,
      executionResults,
      analysis,
      testAspectsCSV: this.config.testAspectsCSV
    });
    
    this.coverageHistory.push(coverage);
    
    // ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜
    await this.reporter.saveIterationReport({
      iteration: this.iteration,
      testPlan,
      executionResults,
      analysis,
      coverage
    });
  }

  async executeTests(testScripts) {
    const results = [];
    
    for (const script of testScripts) {
      console.log(`    Testing: ${script.test_case_id}`);
      
      try {
        const result = await this.agent.executeInstructions(script.instructions);
        results.push({
          test_case_id: script.test_case_id,
          aspect_no: script.aspect_no,
          status: 'success',
          result
        });
      } catch (error) {
        const snapshot = await this.agent.getSnapshot().catch(() => null);
        results.push({
          test_case_id: script.test_case_id,
          aspect_no: script.aspect_no,
          status: 'failed',
          error: error.message,
          snapshot
        });
      }
    }
    
    return results;
  }

  async analyzeResults(executionResults, testPlan) {
    const analyses = [];
    
    for (const result of executionResults) {
      if (result.status === 'failed') {
        const testCase = testPlan.testCases.find(tc => tc.case_id === result.test_case_id);
        
        const analysis = await this.llm.analyze({
          testCase,
          result,
          snapshot: result.snapshot
        });
        
        analyses.push({
          test_case_id: result.test_case_id,
          ...analysis
        });
      }
    }
    
    return analyses;
  }

  async healFailedTests(executionResults, analyses) {
    for (const analysis of analyses) {
      if (!analysis.is_bug) {
        const result = executionResults.find(r => r.test_case_id === analysis.test_case_id);
        
        console.log(`    Healing: ${analysis.test_case_id}`);
        const healed = await this.healer.heal({
          testCaseId: analysis.test_case_id,
          error: result.error,
          snapshot: result.snapshot,
          failureReason: analysis.failure_reason
        });
        
        if (healed.success) {
          console.log(`    âœ… Healed successfully`);
          // ä¿®å¾©ã—ãŸã‚¹ã‚¯ãƒªãƒ—ãƒˆã§å†å®Ÿè¡Œ
          try {
            const retryResult = await this.agent.executeInstructions(healed.instructions);
            result.status = 'healed';
            result.healedResult = retryResult;
          } catch (error) {
            console.log(`    âŒ Retry failed: ${error.message}`);
          }
        }
      } else {
        console.log(`    ğŸ› Bug detected: ${analysis.test_case_id}`);
        await this.reporter.saveBugReport({
          test_case_id: analysis.test_case_id,
          bug_type: analysis.bug_type,
          description: analysis.failure_reason,
          recommendation: analysis.recommendation
        });
      }
    }
  }

  shouldContinue() {
    return this.iteration < this.config.maxIterations;
  }

  getCurrentCoverage() {
    if (this.coverageHistory.length === 0) {
      return {
        aspectCoverage: { total: 23, tested: 0, percentage: 0, untested_aspects: [] },
        functionCoverage: { total: 0, tested: 0, percentage: 0, untested_functions: [] }
      };
    }
    return this.coverageHistory[this.coverageHistory.length - 1];
  }

  isStagnant() {
    if (this.coverageHistory.length < 3) return false;
    
    const recent = this.coverageHistory.slice(-3);
    const percentages = recent.map(c => c.aspectCoverage.percentage);
    
    // 3å›é€£ç¶šã§å¤‰åŒ–ãªã—
    return percentages[0] === percentages[1] && percentages[1] === percentages[2];
  }

  async generateFinalReport() {
    await this.reporter.generateFinalReport({
      config: this.config,
      iterations: this.iteration,
      coverageHistory: this.coverageHistory,
      testResults: this.testResults
    });
  }
}

module.exports = Orchestrator;
```

---

### 2.3 src/agents/othello-planner.jsï¼ˆãƒ†ã‚¹ãƒˆåˆ†æãƒ»è¨ˆç”»ç”Ÿæˆï¼‰

#### 2.3.1 ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰

```javascript
class OthelloPlanner {
  constructor({ llm, config }) {
    this.llm = llm;
    this.config = config;
  }

  async generateTestPlan(options) {
    const { url, testAspectsCSV, existingCoverage, iteration } = options;
    
    // 1. ãƒ†ã‚¹ãƒˆè¦³ç‚¹ãƒªã‚¹ãƒˆã‚’èª­ã¿è¾¼ã¿
    const aspects = await this.loadTestAspects(testAspectsCSV);
    
    // 2. ã‚µã‚¤ãƒˆæ§‹é€ ã‚’å–å¾—ï¼ˆSnapshotã¯å¤–éƒ¨ã‹ã‚‰å–å¾—ï¼‰
    // ï¼ˆã“ã®ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã¯Snapshotã‚’å—ã‘å–ã‚‹æƒ³å®šï¼‰
    
    // 3. æœªãƒ†ã‚¹ãƒˆã®è¦³ç‚¹ã‚’å„ªå…ˆ
    const priorityAspects = this.prioritizeAspects(aspects, existingCoverage);
    
    // 4. LLMã§ãƒ†ã‚¹ãƒˆåˆ†æ
    const analysis = await this.analyzeWithLLM({
      url,
      aspects: priorityAspects,
      existingCoverage,
      iteration
    });
    
    // 5. ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ç”Ÿæˆ
    const testCases = this.extractTestCases(analysis);
    
    // 6. Markdownå½¢å¼ã§ã‚‚ä¿å­˜
    const markdown = this.formatAsMarkdown(analysis);
    
    return {
      iteration,
      aspects: priorityAspects,
      analysis,
      testCases,
      markdown
    };
  }

  async loadTestAspects(csvPath) {
    const fs = require('fs').promises;
    const { parseCSV } = require('../utils/csv-parser');
    
    const csvContent = await fs.readFile(csvPath, 'utf-8');
    const aspects = parseCSV(csvContent);
    
    return aspects.map((row, index) => ({
      aspect_no: parseInt(row['No'], 10) || index + 1,
      quality_characteristic: row['å“è³ªç‰¹æ€§'] || '',
      test_type_major: row['ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ—ä¸­åˆ†é¡'] || '',
      test_type_minor: row['ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ—å°åˆ†é¡'] || '',
      test_aspect: row['ãƒ†ã‚¹ãƒˆè¦³ç‚¹'] || '',
      target_function_template: row['å¯¾è±¡ã®æ©Ÿèƒ½æ§‹é€ '] || '',
      specification_template: row['è€ƒæ…®ã™ã¹ãä»•æ§˜ã®å…·ä½“ä¾‹'] || '',
      target_bug_template: row['ç‹™ã†ãƒã‚°'] || ''
    }));
  }

  prioritizeAspects(aspects, existingCoverage) {
    const tested = existingCoverage.aspectCoverage?.tested || [];
    const untested = aspects.filter(a => !tested.includes(a.aspect_no));
    
    // æœªãƒ†ã‚¹ãƒˆã‚’å„ªå…ˆã€æ¬¡ã«P0/P1ã‚’å„ªå…ˆ
    return [
      ...untested.filter(a => a.priority === 'P0'),
      ...untested.filter(a => a.priority === 'P1'),
      ...untested.filter(a => !['P0', 'P1'].includes(a.priority)),
      ...aspects.filter(a => tested.includes(a.aspect_no))
    ].slice(0, 10); // ä¸€åº¦ã«10è¦³ç‚¹ã¾ã§
  }

  async analyzeWithLLM(options) {
    const { url, aspects, existingCoverage, iteration } = options;
    
    const prompt = this.buildAnalysisPrompt({ url, aspects, existingCoverage, iteration });
    
    const response = await this.llm.chat({
      messages: [
        { role: 'system', content: 'ã‚ãªãŸã¯ãƒ†ã‚¹ãƒˆåˆ†æã®å°‚é–€å®¶ã§ã™ã€‚' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.7,
      maxTokens: 4000
    });
    
    return this.parseAnalysisResponse(response.content);
  }

  buildAnalysisPrompt({ url, aspects, existingCoverage, iteration }) {
    return `
ã‚ãªãŸã¯ãƒ†ã‚¹ãƒˆåˆ†æã®å°‚é–€å®¶ã§ã™ã€‚

ã€å¯¾è±¡URLã€‘
${url}

ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€‘
${iteration}å›ç›®

ã€æ—¢å­˜ã‚«ãƒãƒ¬ãƒƒã‚¸ã€‘
${JSON.stringify(existingCoverage, null, 2)}

ã€ãƒ†ã‚¹ãƒˆè¦³ç‚¹ãƒªã‚¹ãƒˆã€‘ï¼ˆå„ªå…ˆåº¦é †ï¼‰
${aspects.map(a => `
No.${a.aspect_no}: ${a.test_type_major} - ${a.test_type_minor}
è¦³ç‚¹: ${a.test_aspect}
`).join('\n')}

ã€ã‚¿ã‚¹ã‚¯ã€‘
å„ãƒ†ã‚¹ãƒˆè¦³ç‚¹ã«ã¤ã„ã¦ã€ä»¥ä¸‹ã‚’åˆ†æã—ã¦ãã ã•ã„ï¼š

1. **å¯¾è±¡ã®æ©Ÿèƒ½æ§‹é€ **: ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã®ã©ã®ç”»é¢ãƒ»æ©Ÿèƒ½ãƒ»è¦ç´ ãŒè©²å½“ã™ã‚‹ã‹
2. **è€ƒæ…®ã™ã¹ãä»•æ§˜ã®å…·ä½“ä¾‹**: ã“ã®ã‚·ã‚¹ãƒ†ãƒ å›ºæœ‰ã®å…·ä½“çš„ãªä»•æ§˜ï¼ˆ5å€‹ç¨‹åº¦ï¼‰
3. **ç‹™ã†ãƒã‚°**: ã“ã®è¦³ç‚¹ã§è¦‹ã¤ã‘ã‚‹ã¹ããƒã‚°ã®ç¨®é¡ï¼ˆ3å€‹ç¨‹åº¦ï¼‰
4. **ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹**: å…·ä½“çš„ãªãƒ†ã‚¹ãƒˆæ‰‹é †ã¨æœŸå¾…çµæœï¼ˆ2-3ã‚±ãƒ¼ã‚¹ï¼‰

ã€å‡ºåŠ›å½¢å¼ã€‘
JSONé…åˆ—ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

\`\`\`json
[
  {
    "aspect_no": 1,
    "test_type": "è¡¨ç¤ºï¼ˆUIï¼‰",
    "test_category": "ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ/æ–‡è¨€",
    "target_function": "...",
    "specifications": ["...", "..."],
    "target_bugs": ["...", "..."],
    "priority": "P0",
    "test_cases": [
      {
        "case_id": "TC001",
        "title": "...",
        "steps": ["...", "..."],
        "expected_results": ["...", "..."]
      }
    ]
  }
]
\`\`\`
`;
  }

  parseAnalysisResponse(content) {
    // JSONãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º
    const jsonMatch = content.match(/```json\n([\s\S]+?)\n```/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[1]);
    }
    
    // JSONç›´æ¥ã®å ´åˆ
    try {
      return JSON.parse(content);
    } catch (error) {
      console.error('Failed to parse LLM response:', content);
      throw new Error('Invalid LLM response format');
    }
  }

  extractTestCases(analysis) {
    const testCases = [];
    
    for (const aspect of analysis) {
      for (const testCase of aspect.test_cases || []) {
        testCases.push({
          ...testCase,
          aspect_no: aspect.aspect_no,
          test_type: aspect.test_type,
          priority: aspect.priority || 'P2'
        });
      }
    }
    
    return testCases;
  }

  formatAsMarkdown(analysis) {
    let md = '# ãƒ†ã‚¹ãƒˆåˆ†æçµæœ\n\n';
    
    for (const aspect of analysis) {
      md += `## No.${aspect.aspect_no}: ${aspect.test_type} - ${aspect.test_category}\n\n`;
      md += `**å¯¾è±¡ã®æ©Ÿèƒ½æ§‹é€ **: ${aspect.target_function}\n\n`;
      md += `**è€ƒæ…®ã™ã¹ãä»•æ§˜**:\n`;
      for (const spec of aspect.specifications || []) {
        md += `- ${spec}\n`;
      }
      md += `\n**ç‹™ã†ãƒã‚°**:\n`;
      for (const bug of aspect.target_bugs || []) {
        md += `- ${bug}\n`;
      }
      md += `\n**ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹**:\n`;
      for (const tc of aspect.test_cases || []) {
        md += `\n### ${tc.case_id}: ${tc.title}\n\n`;
        md += `**æ‰‹é †**:\n`;
        for (let i = 0; i < tc.steps.length; i++) {
          md += `${i + 1}. ${tc.steps[i]}\n`;
        }
        md += `\n**æœŸå¾…çµæœ**:\n`;
        for (let i = 0; i < tc.expected_results.length; i++) {
          md += `${i + 1}. ${tc.expected_results[i]}\n`;
        }
      }
      md += '\n---\n\n';
    }
    
    return md;
  }
}

module.exports = OthelloPlanner;
```

---

### 2.4 src/agents/othello-generator.jsï¼ˆãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆç”Ÿæˆï¼‰

#### 2.4.1 ã‚¯ãƒ©ã‚¹å®šç¾©
```javascript
class OthelloGenerator {
  constructor({ llm, config }) {
    this.llm = llm;
    this.config = config;
  }

  async generate(options) {
    const { testCases, snapshot, existingCoverage } = options;
    
    const scripts = [];
    
    for (const testCase of testCases) {
      console.log(`    Generating script for: ${testCase.case_id}`);
      
      const script = await this.generateScript({
        testCase,
        snapshot,
        existingCoverage
      });
      
      scripts.push(script);
    }
    
    return scripts;
  }

  async generateScript({ testCase, snapshot }) {
    const prompt = this.buildGeneratorPrompt({ testCase, snapshot });
    
    const response = await this.llm.chat({
      messages: [
        { role: 'system', content: 'ã‚ãªãŸã¯ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆç”Ÿæˆã®å°‚é–€å®¶ã§ã™ã€‚' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.3,
      maxTokens: 2000
    });
    
    const instructions = this.parseInstructions(response.content);
    
    return {
      test_case_id: testCase.case_id,
      aspect_no: testCase.aspect_no,
      instructions
    };
  }

  buildGeneratorPrompt({ testCase, snapshot }) {
    return `
ã‚ãªãŸã¯ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆç”Ÿæˆã®å°‚é–€å®¶ã§ã™ã€‚

ã€ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã€‘
ID: ${testCase.case_id}
ã‚¿ã‚¤ãƒˆãƒ«: ${testCase.title}

æ‰‹é †:
${testCase.steps.map((s, i) => `${i + 1}. ${s}`).join('\n')}

æœŸå¾…çµæœ:
${testCase.expected_results.map((r, i) => `${i + 1}. ${r}`).join('\n')}

ã€ãƒšãƒ¼ã‚¸Snapshotã€‘
${snapshot}

ã€ã‚¿ã‚¹ã‚¯ã€‘
ã“ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®Playwright MCPå‘½ä»¤ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚

ã€ã‚»ãƒ¬ã‚¯ã‚¿æˆ¦ç•¥ã€‘ï¼ˆå„ªå…ˆé †ä½ï¼‰
1. MCPã®\`ref\`ï¼ˆSnapshotå†…ã®"e123"ã®ã‚ˆã†ãªå‚ç…§ï¼‰
2. data-testidå±æ€§
3. ã‚¢ã‚¯ã‚»ã‚·ãƒ–ãƒ«ãªåå‰ï¼ˆrole + nameï¼‰
4. ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ã‚»ãƒ¬ã‚¯ã‚¿
5. CSSã‚»ãƒ¬ã‚¯ã‚¿

ã€å‡ºåŠ›å½¢å¼ã€‘
JSONé…åˆ—ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

\`\`\`json
[
  {
    "type": "navigate",
    "url": "...",
    "description": "..."
  },
  {
    "type": "fill",
    "ref": "e48",
    "selector": "input[name='username']",
    "value": "...",
    "description": "..."
  },
  {
    "type": "click",
    "ref": "e59",
    "selector": "button[type='submit']",
    "description": "..."
  },
  {
    "type": "verify",
    "ref": "e72",
    "selector": ".success-message",
    "expected": "...",
    "description": "..."
  }
]
\`\`\`

ã€é‡è¦ã€‘
- \`ref\`ã¯å¿…ãšSnapshotå†…ã®å®Ÿéš›ã®å€¤ã‚’ä½¿ç”¨
- å¾…æ©ŸãŒå¿…è¦ãªå ´åˆã¯"wait"å‘½ä»¤ã‚’è¿½åŠ 
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ¤œè¨¼ã«ã¯"verify_text_visible"ã‚’ä½¿ç”¨
`;
  }

  parseInstructions(content) {
    const jsonMatch = content.match(/```json\n([\s\S]+?)\n```/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[1]);
    }
    
    try {
      return JSON.parse(content);
    } catch (error) {
      console.error('Failed to parse instructions:', content);
      throw new Error('Invalid instructions format');
    }
  }
}

module.exports = OthelloGenerator;
```

---

### 2.5 src/agents/othello-healer.jsï¼ˆå¤±æ•—ãƒ†ã‚¹ãƒˆè‡ªå‹•ä¿®å¾©ï¼‰

#### 2.5.1 ã‚¯ãƒ©ã‚¹å®šç¾©
```javascript
class OthelloHealer {
  constructor({ llm, config }) {
    this.llm = llm;
    this.config = config;
    this.healingHistory = [];
  }

  async heal(options) {
    const { testCaseId, error, snapshot, failureReason } = options;
    
    // å¤±æ•—ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†é¡
    const category = this.categorizeFailure(error, failureReason);
    
    console.log(`      Failure category: ${category}`);
    
    // ã‚«ãƒ†ã‚´ãƒªã«å¿œã˜ãŸä¿®å¾©ç­–ã‚’ç”Ÿæˆ
    const fix = await this.generateFix({
      testCaseId,
      category,
      error,
      snapshot,
      failureReason
    });
    
    // å±¥æ­´è¨˜éŒ²
    this.healingHistory.push({
      testCaseId,
      category,
      fix,
      timestamp: new Date().toISOString()
    });
    
    return fix;
  }

  categorizeFailure(error, failureReason) {
    const errorLower = error.toLowerCase();
    
    if (errorLower.includes('element not found') || errorLower.includes('selector')) {
      return 'ELEMENT_NOT_FOUND';
    } else if (errorLower.includes('timeout')) {
      return 'TIMEOUT';
    } else if (errorLower.includes('hidden') || errorLower.includes('not visible')) {
      return 'ELEMENT_HIDDEN';
    } else if (errorLower.includes('invalid value') || errorLower.includes('validation')) {
      return 'INVALID_VALUE';
    } else {
      return 'UNKNOWN';
    }
  }

  async generateFix({ testCaseId, category, error, snapshot, failureReason }) {
    const strategy = this.getHealingStrategy(category);
    
    if (strategy.type === 'llm') {
      return await this.healWithLLM({ testCaseId, category, error, snapshot, failureReason });
    } else {
      return this.healWithRule({ testCaseId, category, error, strategy });
    }
  }

  getHealingStrategy(category) {
    const strategies = {
      'ELEMENT_NOT_FOUND': { type: 'llm', description: 'Find alternative selector' },
      'TIMEOUT': { type: 'rule', action: 'increase_timeout', multiplier: 2 },
      'ELEMENT_HIDDEN': { type: 'rule', action: 'scroll_and_wait' },
      'INVALID_VALUE': { type: 'llm', description: 'Generate valid value' },
      'UNKNOWN': { type: 'llm', description: 'Analyze and suggest fix' }
    };
    
    return strategies[category] || strategies['UNKNOWN'];
  }

  async healWithLLM({ testCaseId, category, error, snapshot, failureReason }) {
    const prompt = `
ã‚ãªãŸã¯ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆä¿®å¾©ã®å°‚é–€å®¶ã§ã™ã€‚

ã€å¤±æ•—ã—ãŸãƒ†ã‚¹ãƒˆã€‘
Test Case ID: ${testCaseId}
Category: ${category}
Error: ${error}
Failure Reason: ${failureReason}

ã€ç¾åœ¨ã®Snapshotã€‘
${snapshot}

ã€ã‚¿ã‚¹ã‚¯ã€‘
ã“ã®ãƒ†ã‚¹ãƒˆã‚’ä¿®å¾©ã™ã‚‹ãŸã‚ã®æ–°ã—ã„å‘½ä»¤ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚

ã€å‡ºåŠ›å½¢å¼ã€‘
\`\`\`json
{
  "success": true,
  "instructions": [
    {
      "type": "...",
      "ref": "...",
      "selector": "...",
      "value": "...",
      "description": "..."
    }
  ],
  "explanation": "ä¿®å¾©ã®ç†ç”±"
}
\`\`\`
`;

    const response = await this.llm.chat({
      messages: [
        { role: 'system', content: 'ã‚ãªãŸã¯ãƒ†ã‚¹ãƒˆä¿®å¾©ã®å°‚é–€å®¶ã§ã™ã€‚' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.3,
      maxTokens: 1500
    });
    
    return this.parseFix(response.content);
  }

  healWithRule({ testCaseId, category, error, strategy }) {
    if (strategy.action === 'increase_timeout') {
      return {
        success: true,
        instructions: [
          {
            type: 'wait',
            duration: 5000,
            description: 'Increase wait time'
          }
        ],
        explanation: `Timeout increased by ${strategy.multiplier}x`
      };
    } else if (strategy.action === 'scroll_and_wait') {
      return {
        success: true,
        instructions: [
          {
            type: 'evaluate',
            function: 'window.scrollTo(0, document.body.scrollHeight)',
            description: 'Scroll to bottom'
          },
          {
            type: 'wait',
            duration: 2000,
            description: 'Wait for element to appear'
          }
        ],
        explanation: 'Scroll and wait for element'
      };
    }
    
    return {
      success: false,
      explanation: 'No rule-based fix available'
    };
  }

  parseFix(content) {
    const jsonMatch = content.match(/```json\n([\s\S]+?)\n```/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[1]);
    }
    
    try {
      return JSON.parse(content);
    } catch (error) {
      return {
        success: false,
        explanation: 'Failed to parse fix'
      };
    }
  }
}

module.exports = OthelloHealer;
```

---

### 2.6 src/analyzer.jsï¼ˆã‚«ãƒãƒ¬ãƒƒã‚¸åˆ†æï¼‰

#### 2.6.1 ã‚¯ãƒ©ã‚¹å®šç¾©
```javascript
class Analyzer {
  constructor(config) {
    this.config = config;
  }

  async analyze(options) {
    const { testPlan, executionResults, analysis, testAspectsCSV } = options;
    
    // ãƒ†ã‚¹ãƒˆè¦³ç‚¹ãƒªã‚¹ãƒˆã‚’èª­ã¿è¾¼ã¿
    const allAspects = await this.loadAspects(testAspectsCSV);
    
    // è¦³ç‚¹ã‚«ãƒãƒ¬ãƒƒã‚¸ç®—å‡º
    const aspectCoverage = this.calculateAspectCoverage(testPlan, executionResults, allAspects);
    
    // æ©Ÿèƒ½ã‚«ãƒãƒ¬ãƒƒã‚¸ç®—å‡º
    const functionCoverage = this.calculateFunctionCoverage(testPlan, executionResults);
    
    // ç”»é¢ã‚«ãƒãƒ¬ãƒƒã‚¸ç®—å‡º
    const screenCoverage = this.calculateScreenCoverage(testPlan, executionResults);
    
    // æ¬¡ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆææ¡ˆ
    const nextTargets = this.suggestNextTargets(aspectCoverage, functionCoverage);
    
    return {
      aspectCoverage,
      functionCoverage,
      screenCoverage,
      nextTargets
    };
  }

  async loadAspects(csvPath) {
    const fs = require('fs').promises;
    const { parseCSV } = require('./utils/csv-parser');
    
    const csvContent = await fs.readFile(csvPath, 'utf-8');
    return parseCSV(csvContent);
  }

  calculateAspectCoverage(testPlan, executionResults, allAspects) {
    const testedAspects = new Set();
    
    // æˆåŠŸã—ãŸãƒ†ã‚¹ãƒˆã®è¦³ç‚¹ã‚’åé›†
    for (const result of executionResults) {
      if (result.status === 'success' || result.status === 'healed') {
        testedAspects.add(result.aspect_no);
      }
    }
    
    const total = allAspects.length;
    const tested = testedAspects.size;
    const percentage = (tested / total) * 100;
    
    const untestedAspects = allAspects
      .filter(a => !testedAspects.has(parseInt(a['No'], 10)))
      .map(a => parseInt(a['No'], 10));
    
    return {
      total,
      tested,
      percentage: Math.round(percentage * 10) / 10,
      untested_aspects: untestedAspects,
      tested_aspects: Array.from(testedAspects)
    };
  }

  calculateFunctionCoverage(testPlan, executionResults) {
    const allFunctions = new Set();
    const testedFunctions = new Set();
    
    // ãƒ†ã‚¹ãƒˆè¨ˆç”»ã‹ã‚‰å…¨æ©Ÿèƒ½ã‚’åé›†
    for (const aspect of testPlan.analysis || []) {
      if (aspect.target_function) {
        allFunctions.add(aspect.target_function);
      }
    }
    
    // æˆåŠŸã—ãŸãƒ†ã‚¹ãƒˆã®æ©Ÿèƒ½ã‚’åé›†
    for (const result of executionResults) {
      if (result.status === 'success' || result.status === 'healed') {
        const aspect = (testPlan.analysis || []).find(a => a.aspect_no === result.aspect_no);
        if (aspect && aspect.target_function) {
          testedFunctions.add(aspect.target_function);
        }
      }
    }
    
    const total = allFunctions.size;
    const tested = testedFunctions.size;
    const percentage = total > 0 ? (tested / total) * 100 : 0;
    
    return {
      total,
      tested,
      percentage: Math.round(percentage * 10) / 10,
      untested_functions: Array.from(allFunctions).filter(f => !testedFunctions.has(f)),
      tested_functions: Array.from(testedFunctions)
    };
  }

  calculateScreenCoverage(testPlan, executionResults) {
    // ç°¡æ˜“å®Ÿè£…: URLé·ç§»ã‚’è¿½è·¡
    const visitedUrls = new Set();
    
    for (const result of executionResults) {
      if (result.result && result.result.url) {
        visitedUrls.add(result.result.url);
      }
    }
    
    return {
      visited_screens: Array.from(visitedUrls),
      count: visitedUrls.size
    };
  }

  suggestNextTargets(aspectCoverage, functionCoverage) {
    return {
      priority_aspects: aspectCoverage.untested_aspects.slice(0, 5),
      priority_functions: functionCoverage.untested_functions.slice(0, 3),
      recommendation: this.generateRecommendation(aspectCoverage, functionCoverage)
    };
  }

  generateRecommendation(aspectCoverage, functionCoverage) {
    if (aspectCoverage.percentage < 50) {
      return 'åŸºæœ¬çš„ãªãƒ†ã‚¹ãƒˆè¦³ç‚¹ã‚’å„ªå…ˆçš„ã«ã‚«ãƒãƒ¼ã—ã¦ãã ã•ã„';
    } else if (aspectCoverage.percentage < 80) {
      return 'æœªã‚«ãƒãƒ¼ã®é‡è¦æ©Ÿèƒ½ã«ç„¦ç‚¹ã‚’å½“ã¦ã¦ãã ã•ã„';
    } else {
      return 'ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã‚„çµ„ã¿åˆã‚ã›ãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã—ã¦ãã ã•ã„';
    }
  }
}

module.exports = Analyzer;
```

---

### 2.7 src/reporter.jsï¼ˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆï¼‰

#### 2.7.1 ã‚¯ãƒ©ã‚¹å®šç¾©
```javascript
const fs = require('fs').promises;
const path = require('path');

class Reporter {
  constructor(config) {
    this.config = config;
    this.outputDir = config.outputDir || './reports';
  }

  async saveIterationReport(data) {
    const { iteration, testPlan, executionResults, analysis, coverage } = data;
    
    // Markdownå½¢å¼ã§ä¿å­˜
    const markdown = this.generateIterationMarkdown(data);
    const mdPath = path.join(this.outputDir, `test-plan-iteration-${iteration}.md`);
    await fs.mkdir(this.outputDir, { recursive: true });
    await fs.writeFile(mdPath, markdown, 'utf-8');
    
    // JSONå½¢å¼ã§ã‚‚ä¿å­˜
    const jsonPath = path.join(this.outputDir, `iteration-${iteration}.json`);
    await fs.writeFile(jsonPath, JSON.stringify(data, null, 2), 'utf-8');
    
    console.log(`  ğŸ“„ Iteration report saved: ${mdPath}`);
  }

  generateIterationMarkdown(data) {
    const { iteration, testPlan, executionResults, coverage } = data;
    
    let md = `# Iteration ${iteration} - Test Report\n\n`;
    md += `## Coverage Summary\n\n`;
    md += `- **Aspect Coverage**: ${coverage.aspectCoverage.percentage}% (${coverage.aspectCoverage.tested}/${coverage.aspectCoverage.total})\n`;
    md += `- **Function Coverage**: ${coverage.functionCoverage.percentage}% (${coverage.functionCoverage.tested}/${coverage.functionCoverage.total})\n\n`;
    
    md += `## Test Results\n\n`;
    const successCount = executionResults.filter(r => r.status === 'success' || r.status === 'healed').length;
    md += `- **Total**: ${executionResults.length}\n`;
    md += `- **Success**: ${successCount}\n`;
    md += `- **Failed**: ${executionResults.length - successCount}\n\n`;
    
    md += `## Test Plan\n\n`;
    md += testPlan.markdown || '';
    
    return md;
  }

  async saveBugReport(bugData) {
    const { test_case_id, bug_type, description, recommendation } = bugData;
    
    const bugDir = path.join(this.outputDir, 'bug-reports');
    await fs.mkdir(bugDir, { recursive: true });
    
    const bugReport = `# Bug Report: ${test_case_id}\n\n`;
    const bugPath = path.join(bugDir, `${test_case_id}-${Date.now()}.md`);
    
    await fs.writeFile(bugPath, bugReport + `
## Bug Type
${bug_type}

## Description
${description}

## Recommendation
${recommendation}

## Timestamp
${new Date().toISOString()}
`, 'utf-8');
    
    console.log(`  ğŸ› Bug report saved: ${bugPath}`);
  }

  async generateFinalReport(data) {
    const { config, iterations, coverageHistory } = data;
    
    // HTMLå½¢å¼ã§ç”Ÿæˆ
    const html = this.generateFinalHTML(data);
    const htmlPath = path.join(this.outputDir, 'final-report.html');
    await fs.writeFile(htmlPath, html, 'utf-8');
    
    // JSONå½¢å¼ã§ã‚‚ä¿å­˜
    const summary = {
      url: config.url,
      iterations,
      final_coverage: coverageHistory[coverageHistory.length - 1],
      coverage_history: coverageHistory,
      timestamp: new Date().toISOString()
    };
    
    const jsonPath = path.join(this.outputDir, 'coverage-report.json');
    await fs.writeFile(jsonPath, JSON.stringify(summary, null, 2), 'utf-8');
    
    console.log(`\nğŸ“Š Final report: ${htmlPath}`);
  }

  generateFinalHTML(data) {
    const { config, iterations, coverageHistory } = data;
    const finalCoverage = coverageHistory[coverageHistory.length - 1];
    
    return `<!DOCTYPE html>
<html>
<head>
  <title>Othello Test Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .summary { background: #f0f0f0; padding: 20px; border-radius: 5px; }
    .chart { margin: 20px 0; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #4CAF50; color: white; }
  </style>
</head>
<body>
  <h1>ğŸ­ Othello Test Report</h1>
  
  <div class="summary">
    <h2>Summary</h2>
    <p><strong>Target URL:</strong> ${config.url}</p>
    <p><strong>Iterations:</strong> ${iterations}</p>
    <p><strong>Final Aspect Coverage:</strong> ${finalCoverage.aspectCoverage.percentage}%</p>
    <p><strong>Final Function Coverage:</strong> ${finalCoverage.functionCoverage.percentage}%</p>
  </div>
  
  <h2>Coverage Progress</h2>
  <table>
    <tr>
      <th>Iteration</th>
      <th>Aspect Coverage (%)</th>
      <th>Function Coverage (%)</th>
    </tr>
    ${coverageHistory.map((c, i) => `
    <tr>
      <td>${i + 1}</td>
      <td>${c.aspectCoverage.percentage}</td>
      <td>${c.functionCoverage.percentage}</td>
    </tr>
    `).join('')}
  </table>
  
  <p><em>Generated by Othello v2.0 on ${new Date().toISOString()}</em></p>
</body>
</html>`;
  }
}

module.exports = Reporter;
```

---

## 3. ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

### 3.1 ãƒ†ã‚¹ãƒˆè¦³ç‚¹ãƒªã‚¹ãƒˆCSVå½¢å¼
```csv
No,å“è³ªç‰¹æ€§,ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ—ä¸­åˆ†é¡,ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ—å°åˆ†é¡,ãƒ†ã‚¹ãƒˆè¦³ç‚¹
1,-,è¡¨ç¤ºï¼ˆUIï¼‰,ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ/æ–‡è¨€,ã‚¢ã‚¤ãƒ†ãƒ ã®é…ç½®/è¡¨ç¤ºã‚µã‚¤ã‚ºã¯ï¼Ÿ
2,-,è¡¨ç¤ºï¼ˆUIï¼‰,ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºï¼ˆæ­£å¸¸ç³»ï¼‰,ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã‚ã‚‹ï¼Ÿ
...
```

### 3.2 ãƒ†ã‚¹ãƒˆåˆ†æçµæœJSON
```json
{
  "aspect_no": 1,
  "test_type": "è¡¨ç¤ºï¼ˆUIï¼‰",
  "test_category": "ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ/æ–‡è¨€",
  "target_function": "ãƒ›ãƒ†ãƒ«ãƒ—ãƒ©ãƒ³ä¸€è¦§ãƒšãƒ¼ã‚¸",
  "specifications": ["...", "..."],
  "target_bugs": ["...", "..."],
  "priority": "P0",
  "test_cases": [
    {
      "case_id": "TC001",
      "title": "...",
      "steps": ["...", "..."],
      "expected_results": ["...", "..."]
    }
  ]
}
```

### 3.3 MCPå‘½ä»¤JSON
```json
{
  "test_case_id": "TC001",
  "aspect_no": 1,
  "instructions": [
    {
      "type": "navigate",
      "url": "...",
      "description": "..."
    },
    {
      "type": "fill",
      "ref": "e48",
      "selector": "...",
      "value": "...",
      "description": "..."
    }
  ]
}
```

---

## 4. APIä»•æ§˜

### 4.1 LLM APIï¼ˆClaudeï¼‰
```javascript
// Anthropic Claude API
const response = await axios.post('https://api.anthropic.com/v1/messages', {
  model: 'claude-3-5-sonnet-20241022',
  max_tokens: 4000,
  messages: [
    { role: 'user', content: prompt }
  ]
}, {
  headers: {
    'x-api-key': process.env.ANTHROPIC_API_KEY,
    'anthropic-version': '2023-06-01',
    'content-type': 'application/json'
  }
});
```

### 4.2 Playwright MCP
```javascript
// MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆPhase 8å®Ÿè£…æ¸ˆã¿ï¼‰
const client = new MCPStdioClient({
  command: 'npx',
  args: ['-y', '@playwright/mcp@latest']
});

await client.connect();

const result = await client.callTool('browser_navigate', {
  url: 'https://example.com',
  intent: 'Navigate to target page'
});
```

---

## 5. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### 5.1 ã‚¨ãƒ©ãƒ¼ç¨®åˆ¥
| ã‚¨ãƒ©ãƒ¼ç¨®åˆ¥ | å¯¾å¿œ |
|-----------|------|
| LLM API ã‚¨ãƒ©ãƒ¼ | ãƒªãƒˆãƒ©ã‚¤ï¼ˆ3å›ã¾ã§ã€æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ï¼‰ |
| MCPé€šä¿¡ã‚¨ãƒ©ãƒ¼ | ã‚»ãƒƒã‚·ãƒ§ãƒ³å†æ¥ç¶š |
| ã‚»ãƒ¬ã‚¯ã‚¿ã‚¨ãƒ©ãƒ¼ | Healerèµ·å‹• |
| ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ | Healerèµ·å‹• |
| äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ | ãƒ­ã‚°è¨˜éŒ²ã—ã¦ã‚¹ã‚­ãƒƒãƒ— |

---

## 6. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### 6.1 ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
- ã™ã¹ã¦ã®ã‚¯ãƒ©ã‚¹ã«å¯¾ã—ã¦Jestãƒ†ã‚¹ãƒˆ
- ãƒ¢ãƒƒã‚¯ä½¿ç”¨ï¼ˆLLMã€MCPï¼‰
- ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™: 80%ä»¥ä¸Š

### 6.2 çµ±åˆãƒ†ã‚¹ãƒˆ
- `__tests__/integration/full-cycle.test.js`
- å®Ÿéš›ã®MCPé€šä¿¡ã‚ã‚Šï¼ˆãƒ†ã‚¹ãƒˆã‚µã‚¤ãƒˆä½¿ç”¨ï¼‰
- 1ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œå…¨å®Ÿè¡Œ

---

## 7. è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆconfig/default.jsonï¼‰

```json
{
  "maxIterations": 10,
  "coverageTarget": 80,
  "browser": "chromium",
  "outputDir": "./reports",
  "testAspectsCSV": "./config/test-ViewpointList.csv",
  "autoHeal": true,
  "llmProvider": "claude",
  "llmConfig": {
    "claude": {
      "model": "claude-3-5-sonnet-20241022",
      "maxTokens": 4000,
      "temperature": 0.7,
      "apiKey": "${ANTHROPIC_API_KEY}"
    },
    "openai": {
      "model": "gpt-4",
      "maxTokens": 4000,
      "temperature": 0.7,
      "apiKey": "${OPENAI_API_KEY}"
    }
  },
  "mcpConfig": {
    "command": "npx",
    "args": ["-y", "@playwright/mcp@latest"],
    "timeout": 30000,
    "retryConfig": {
      "maxRetries": 3,
      "initialDelay": 1000,
      "maxDelay": 10000,
      "backoffMultiplier": 2
    }
  }
}
```

---

**ä½œæˆè€…**: Othelloé–‹ç™ºãƒãƒ¼ãƒ   
**æœ€çµ‚æ›´æ–°**: 2025å¹´10æœˆ23æ—¥  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 2.0ï¼ˆPhase 9ç‰ˆï¼‰
